/*
 * audio.c - Audio subsystem for previewing notes
 *
 * Copyright (C) 2020-2022 M-374 LX <wilsalx@gmail.com>
 *
 * Partially based on Nuke.YKT's fork of Genesis Plus GX, itself originally
 * by Charles MacDonald and Eke-Eke.
 *
 * This file is part of Pseym.
 *
 * Pseym is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * Pseym is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with Pseym; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 */

#include <SDL2/SDL.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include "blip_buf.h"
#include "ym3438.h"

#define MCLOCK_NTSC 53693175
#define MCLOCK_PAL  53203424
#define MCYCLES_PER_LINE 3420
#define MCYCLES_PER_FRAME 262 * MCYCLES_PER_LINE
#define YM2612_CLOCK_RATIO (7 * 6)

#define SAMPLE_RATE 48000
#define SOUND_SAMPLES_SIZE 2048

static ym3438_t ym3438;
static short ym3438_accm[24][2];
static int ym3438_sample[2];
static int ym3438_cycles;

static int fm_buffer[1080 * 2 * 24];

static int fm_last[2];
static int* fm_ptr;

static int fm_cycles_ratio;
static int fm_cycles_start;
static int fm_cycles_count;

static blip_t* blip;

//A queue with values to be written to the YM2612; even positions cointain
//register numbers and odd positions contain the values
//
//On an even position, the special value 0xFF enables playing notes and it is
//always followed by zero
//
//On an even position, the special value 0xFE is followed by either 0 or 1, 
//which causes the next values to be written to the respective part of the
//emulated FM chip (1 or 2)
static uint8_t fm_write_queue[512];
static int fm_write_queue_length;
static int fm_write_queue_pos;
static bool fm_notes_enabled;
static int fm_write_part;
static int fm_write_part_add;

static char* audio_cur_pos;
static char* audio_buffer;
static short audio_frame[SOUND_SAMPLES_SIZE];

//Number of samples generated by the emulated audio system but not yet played
//by the host system
static int num_emulated_samples;

static const uint16_t notes[] = {
	644,  //C
	681,  //C#
	722,  //D
	765,  //D#
	810,  //E
	858,  //F
	910,  //F#
	964,  //G
	1021, //G#
	1081, //A
	1146, //A#
	1214, //B
};

static void fm_update(int cycles)
{
	if (cycles <= fm_cycles_count) {
		return;
	}

	int samples = (cycles - fm_cycles_count + fm_cycles_ratio - 1) / fm_cycles_ratio;
	int* buffer = fm_ptr;
	int i, j;

	for (i = 0; i < samples; i++) {
		OPN2_Clock(&ym3438, ym3438_accm[ym3438_cycles]);
		ym3438_cycles = (ym3438_cycles + 1) % 24;

		if (ym3438_cycles == 0) {
			ym3438_sample[0] = 0;
			ym3438_sample[1] = 0;

			for (j = 0; j < 24; j++) {
				ym3438_sample[0] += ym3438_accm[j][0];
				ym3438_sample[1] += ym3438_accm[j][1];
			}
		}

		*buffer++ = ym3438_sample[0] * 11;
		*buffer++ = ym3438_sample[1] * 11;
	}

	fm_ptr += (samples * 2);
	fm_cycles_count += (samples * fm_cycles_ratio);
}

static uint8_t ym_read(int cycles, uint8_t a)
{
	fm_update(cycles);
	return OPN2_Read(&ym3438, a);
}

static void ym_write(int cycles, uint8_t a, uint8_t v)
{
	fm_update(cycles);
	OPN2_Write(&ym3438, a, v);
}

void fm_write_reg(uint8_t reg, uint8_t val, uint8_t part)
{
	if (part != fm_write_part_add) {
		fm_write_part_add = part;
		fm_write_queue[fm_write_queue_length++] = 0xFE;
		fm_write_queue[fm_write_queue_length++] = part;
	}

	fm_write_queue[fm_write_queue_length++] = reg;
	fm_write_queue[fm_write_queue_length++] = val;
}

void fm_enable_notes()
{
	fm_write_queue[fm_write_queue_length++] = 0xFF;
	fm_write_queue[fm_write_queue_length++] = 0x00;
}

void fm_key_off(uint8_t chan)
{
	if (fm_notes_enabled) {
		fm_write_reg(0x28, chan, 0);
	}
}

void fm_key_on(uint8_t oct, uint8_t note, uint8_t chan)
{
	if (!fm_notes_enabled || oct > 7) {
		return;
	}

	//Key off
	fm_write_reg(0x28, chan, 0);

	//Set frequency
	fm_write_reg(0xA4 + chan, (notes[note] >> 8) | (oct << 3), 0);
	fm_write_reg(0xA0 + chan, (notes[note] & 0xFF), 0);

	//Key on
	fm_write_reg(0x28, 0xF0 + chan, 0);
}

static void fm_write_queue_update()
{
	if (fm_write_queue_length == 0) {
		return;
	}

	int cycles = fm_cycles_count + 96;
	uint8_t a;

	while (1) {
		if (fm_write_queue_pos >= fm_write_queue_length) {
			fm_write_queue_length = 0;
			fm_write_queue_pos = 0;
			fm_write_part = 0;
			fm_write_part_add = 0;
			return;
		}

		if (fm_write_queue[fm_write_queue_pos] == 0xFF) {
			//Special value to enable playing notes
			fm_notes_enabled = true;
			fm_write_queue_pos += 2;
		} else if (fm_write_queue[fm_write_queue_pos] == 0xFE) {
			//Special value to set the part of the FM chip to write to
			fm_write_part = fm_write_queue[fm_write_queue_pos + 1];
			fm_write_queue_pos += 2;
		} else {
			//Regular register write

			//Wait while the emulated sound chip is busy
			while (ym_read(cycles, 0) & 0x80) {
				cycles += 240;
			}

			//Write register number
			a = fm_write_part * 2;
			ym_write(cycles, a, fm_write_queue[fm_write_queue_pos + 0]);
			cycles += 48;

			//Write value to register
			a += 1;
			ym_write(cycles, a, fm_write_queue[fm_write_queue_pos + 1]);
			cycles += 240;

			fm_update(cycles);
			fm_write_queue_pos += 2;
		}
	}
}

static void audio_callback(void* userdata, uint8_t* stream, int len)
{
	if (num_emulated_samples < len) {
		memset(stream, 0, len);
	} else {
		memcpy(stream, audio_buffer, len);

		do {
			num_emulated_samples -= len;
		} while (num_emulated_samples > 2 * len);

		memcpy(audio_buffer, audio_cur_pos - num_emulated_samples, num_emulated_samples);

		audio_cur_pos = audio_buffer + num_emulated_samples;
	}
}


static void fm_regs_init()
{
	fm_write_reg(0x22, 0x00, 0); //Disable LFO
	fm_write_reg(0x27, 0x00, 0); //Channel 3 normal mode and timer disabled
	fm_write_reg(0x2B, 0x00, 0); //Disable DAC

	//Enable left and right for first three channels
	fm_write_reg(0xB4, 0xC0, 0);
	fm_write_reg(0xB5, 0xC0, 0);
	fm_write_reg(0xB6, 0xC0, 0);

	//Disable left and right for last three channels
	fm_write_reg(0xB4, 0x00, 1);
	fm_write_reg(0xB5, 0x00, 1);
	fm_write_reg(0xB6, 0x00, 1);

	//Key off for all channels
	fm_write_reg(0x28, 0, 0);
	fm_write_reg(0x28, 1, 0);
	fm_write_reg(0x28, 2, 0);
	fm_write_reg(0x28, 4, 0);
	fm_write_reg(0x28, 5, 0);
	fm_write_reg(0x28, 6, 0);
}


bool audio_buffer_full()
{
	return num_emulated_samples > 12000;
}

bool audio_init()
{
	SDL_AudioSpec as;
	int n;

	memset(&ym3438, 0, sizeof(ym3438));
	memset(&ym3438_accm, 0, sizeof(ym3438_accm));
	memset(&ym3438_sample, 0, sizeof(ym3438_sample));
	fm_cycles_ratio = YM2612_CLOCK_RATIO;

	blip = blip_new(SAMPLE_RATE / 10);
	if (!blip) {
		return false;
	}

	blip_set_rates(blip, MCLOCK_NTSC, SAMPLE_RATE);
	blip_clear(blip);

	OPN2_Reset(&ym3438);

	fm_last[0] = fm_last[1] = 0;
	fm_ptr = fm_buffer;
	fm_cycles_start = fm_cycles_count = 0;

	as.freq = SAMPLE_RATE;
	as.format = AUDIO_S16LSB;
	as.channels = 2;
	as.samples = SOUND_SAMPLES_SIZE;
	as.callback = audio_callback;

	if (SDL_OpenAudio(&as, NULL) < 0) {
		return false;
	}

	num_emulated_samples = 0;
	n = SOUND_SAMPLES_SIZE * 2 * sizeof(short) * 20;

	audio_buffer = (char*)malloc(n);
	if (!audio_buffer) {
		return false;
	}

	memset(audio_buffer, 0, n);
	audio_cur_pos = audio_buffer;

	SDL_PauseAudio(0);

	fm_write_queue_length = 0;
	fm_write_queue_pos = 0;
	fm_notes_enabled = false;
	fm_write_part = 0;
	fm_write_part_add = 0;

	fm_regs_init();

	return true;
}

void audio_update()
{
	int prev_l, prev_r, time, l, r, *ptr, size;
	int cycles = MCYCLES_PER_FRAME;
	short *out;
	int i;

	fm_write_queue_update();
	fm_update(cycles);

	time = fm_cycles_start;
	prev_l = fm_last[0];
	prev_r = fm_last[1];
	ptr = fm_buffer;

	do {
		l = *ptr++;
		r = *ptr++;

		blip_add_delta(blip, time, l - prev_l, r - prev_r);
		prev_l = l;
		prev_r = r;

		time += fm_cycles_ratio;
	} while (time < cycles);

	fm_ptr = fm_buffer;

	fm_last[0] = prev_l;
	fm_last[1] = prev_r;

	fm_cycles_count = fm_cycles_start = time - cycles;

	blip_end_frame(blip, cycles);

	size = blip_samples_avail(blip);
	blip_read_samples(blip, audio_frame, size);

	SDL_LockAudio();
	size *= 2;
	out = (short*)audio_cur_pos;
	for (i = 0; i < size; i++) {
		*out++ = audio_frame[i];
	}
	audio_cur_pos = (char*)out;
	num_emulated_samples += size * sizeof(short);
	SDL_UnlockAudio();
}

void audio_shutdown()
{
	blip_delete(blip);
	blip = 0;

	SDL_PauseAudio(1);
	SDL_CloseAudio();

	if (audio_buffer) {
		free(audio_buffer);
	}
}

